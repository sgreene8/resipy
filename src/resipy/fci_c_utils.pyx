#cython: boundscheck=False, wraparound=False, cdivision=True
"""
Cython-based utilities for manipulating bit-string representations of Slater
determinants and calculating FCI matrix elements. See fci_utils.py for more
information.
"""

import numpy
from libc.stdio cimport printf
from libc.math cimport fabs
from cython.parallel import prange, threadid
cimport numpy
cimport openmp


def gen_orb_lists(long long[:] dets, unsigned int num_elec, unsigned char[:] lookup_nums,
                  unsigned char[:, :] lookup_idx):
    """Generate arrays of indices of occupied orbitals from bit string
    representations of Slater determinants, following procedure in Sec. 3.1 of
    Booth et al. (2014).

    Parameters
    ----------
    dets : (numpy.ndarray, int64)
        array of bit strings to parse. all must have the same number of occupied
        orbitals,and the same number unoccupied
    num_elec : (unsigned int)
        number of electrons in the system
    lookup_nums : (numpy.ndarray, uint8)
        the first of the lookup tables generated by fci_utils.gen_byte_table()
    lookup_idx : (numpy.ndarray, uint8)
        the second of the lookup tables generated by fci_utils.gen_byte_table()

    Returns
    -------
    (numpy.ndarray, uint8) :
        indices of occupied orbitals for each determinant
    """

    cdef size_t n_dets = dets.shape[0]
    cdef numpy.ndarray[numpy.uint8_t, ndim=2] occ_orbs = numpy.zeros([n_dets, num_elec],
                                                                     dtype=numpy.uint8)
    cdef unsigned int byte_idx, elec_idx
    cdef size_t det_idx
    cdef long long curr_det, mask = 255
    cdef unsigned char n_elec, det_byte, bit_idx

    for det_idx in prange(n_dets, nogil=True, schedule=static):
        curr_det = dets[det_idx]
        elec_idx = 0
        byte_idx = 0
        while curr_det != 0:
            det_byte = curr_det & mask
            n_elec = lookup_nums[det_byte]
            for bit_idx in range(n_elec):
                occ_orbs[det_idx, elec_idx + bit_idx] = (8 * byte_idx +
                                                         lookup_idx[det_byte,
                                                                    bit_idx])
            elec_idx = elec_idx + n_elec
            curr_det = curr_det >> 8
            byte_idx = byte_idx + 1

    return occ_orbs


def doub_matr_el_nosgn(unsigned char[:, :] chosen_idx, double[:, :, :, :] eris,
                       unsigned int n_frozen):
    """Calculate the matrix elements for double excitations without accounting
        for the parity of the excitations.

        Parameters
        ----------
        chosen_idx : (numpy.ndarray, unsigned int)
            the chosen indices of the two occupied orbitals (0th and 1st
            columns) and two virtual orbitals (2nd and 3rd columns) in each
            excitation
        eris : (numpy.ndarray, float)
            4-D array of 2-electron integrals in spatial MO basis
        n_frozen : (unsigned int)
            number of core electrons frozen in the calculation

        Returns
        -------
        (numpy.ndarray, float)
            matrix elements for all excitations
    """
    cdef unsigned int adj_n_orb = eris.shape[0] - n_frozen / 2
    cdef size_t n_samp = chosen_idx.shape[0]
    cdef numpy.ndarray[numpy.float64_t] matrix_el = numpy.zeros(n_samp)
    cdef size_t samp_idx
    cdef unsigned char sp0, sp1, sp2, sp3
    cdef int same_sp
    cdef double mat_el

    for samp_idx in prange(n_samp, nogil=True, schedule=static):
        matrix_el[samp_idx] = _doub_mel(&chosen_idx[samp_idx, 0], eris, n_frozen)

    return matrix_el


cdef double _doub_mel(unsigned char *orbs, double[:, :, :, :] eris, unsigned int n_frozen) nogil:
    cdef unsigned char sp0, sp1, sp2, sp3
    cdef unsigned int adj_n_orb = eris.shape[0] - n_frozen / 2
    sp0 = orbs[0]
    sp1 = orbs[1]
    cdef int same_sp = sp0 / adj_n_orb == sp1 / adj_n_orb
    sp0 = (sp0 % adj_n_orb) + n_frozen / 2
    sp1 = (sp1 % adj_n_orb) + n_frozen / 2
    sp2 = (orbs[2] % adj_n_orb) + n_frozen / 2
    sp3 = (orbs[3] % adj_n_orb) + n_frozen / 2

    cdef double mat_el = eris[sp0, sp1, sp2, sp3]
    if same_sp:
        mat_el -= eris[sp0, sp1, sp3, sp2]
    return mat_el


def single_dets_matrel_nosgn(numpy.ndarray[numpy.int64_t] dets,
                             numpy.ndarray[numpy.uint8_t, ndim=2] ex_orbs,
                             double[:, :, :, :] eris, double[:, :] hcore,
                             unsigned char[:, :] occ_orbs, unsigned int n_frozen):
    '''Calculate matrix elements and resulting determinants for single
    excitations.

    Parameters
    ----------
    dets : (numpy.ndarray, int64)
        bit string representations of origin determinants from which to excite
    ex_orbs : (numpy.ndarray, uint8)
        indices of occupied (0th column) and unoccupied (1st column) orbitals
        involved in the excitation
    eris : (numpy.ndarray, float64)
        2-electron integrals from Hartree-Fock calculation
    hcore : (numpy.ndarray, float64)
        1-electron integrals from  Hartree-Fock calculation
    occ_orbs : (numpy.ndarray, uint8)
        orbitals occupied in each origin determinant
    n_frozen : (unsigned int)
        number of core electrons frozen in the calculation
    '''
    cdef unsigned int n_elec = occ_orbs.shape[1]
    cdef size_t n_dets = dets.shape[0]
    cdef unsigned int n_orb = eris.shape[0]
    cdef numpy.ndarray[numpy.float64_t] matrix_el = numpy.zeros(n_dets,
                                                                dtype=numpy.float64)
    cdef double matr_sum
    cdef size_t i
    cdef unsigned int j, occ_spa, unocc_spa, occ_spin
    cdef unsigned int eris_idx = 0
    cdef unsigned int half_frz = n_frozen / 2

    for i in prange(n_dets, nogil=True, schedule=static):
        matrix_el[i] = _sing_mel(ex_orbs[i, 0], ex_orbs[i, 1], &occ_orbs[i, 0], half_frz, eris, hcore, n_elec)

    one = numpy.ones(1, dtype=numpy.int64)
    excited_dets = dets ^ (one << ex_orbs[:, 0])
    excited_dets ^= one << ex_orbs[:, 1]
    return excited_dets, matrix_el


cdef double _sing_mel(unsigned char occ, unsigned char unocc, unsigned char *occ_orbs,
                      unsigned int half_frz, double[:, :, :, :] eris, double[:, :] hcore,
                      unsigned int n_elec) nogil:
    # Calculate one single-excitation matrix element
    cdef unsigned int num_orb = eris.shape[0]
    # cdef unsigned int n_elec = occ_orbs.shape[0]
    cdef unsigned char occ_spa = (occ % (num_orb - half_frz)) + half_frz
    cdef unsigned char unocc_spa = (unocc % (num_orb - half_frz)) + half_frz
    cdef unsigned int occ_spin = occ / (num_orb - half_frz)
    cdef double mat_el = hcore[occ_spa, unocc_spa]
    cdef unsigned int j

    for j in range(half_frz):
        # double-count coulomb term
        mat_el += eris[occ_spa, j, unocc_spa, j] * 2
        # single-count exchange term
        mat_el -= eris[occ_spa, j, j, unocc_spa]
    for j in range(n_elec / 2):
        mat_el += eris[occ_spa, occ_orbs[j] + half_frz,
                       unocc_spa, occ_orbs[j] + half_frz]
        if occ_spin == 0:
            mat_el -= eris[occ_spa, occ_orbs[j] + half_frz,
                           occ_orbs[j] + half_frz, unocc_spa]
    for j in range(n_elec / 2, n_elec):
        mat_el += eris[occ_spa, occ_orbs[j] - num_orb + half_frz * 2,
                       unocc_spa, occ_orbs[j] - num_orb + half_frz * 2]
        if occ_spin == 1:
            mat_el -= eris[occ_spa, occ_orbs[j] - num_orb + half_frz * 2,
                           occ_orbs[j] - num_orb + half_frz * 2, unocc_spa]
    return mat_el


def ray_off_diag(long long[:] dets, double[:] values, unsigned char[:, :] occ_orbs,
                 double[:, :] hcore, double[:, :, :, :] eris, unsigned int n_frozen,
                 unsigned char[:] orb_symm):
    cdef size_t n_dets = dets.shape[0]
    cdef size_t row_det_idx, col_det_idx
    cdef unsigned int n_threads = openmp.omp_get_max_threads()
    cdef unsigned int thread_idx

    cdef unsigned int num_elec = occ_orbs.shape[1]
    cdef unsigned int num_orb = orb_symm.shape[0]
    cdef unsigned int num_sing_ex = num_elec * (num_orb - num_elec / 2)
    cdef numpy.ndarray[numpy.uint8_t, ndim=3] sing_ex = numpy.zeros([n_threads, num_sing_ex, 2], dtype=numpy.uint8)
    cdef size_t n_sing, n_doub, ex_idx

    cdef unsigned int n_unocc = num_orb - num_elec / 2
    cdef unsigned int n_same = num_elec * (num_elec / 2 - 1) / 2 * n_unocc * (n_unocc - 1) / 2
    cdef unsigned int n_diff = num_elec / 2 * num_elec / 2 * n_unocc ** 2
    cdef numpy.ndarray[numpy.uint8_t, ndim=3] doub_ex = numpy.zeros([n_threads, n_same + n_diff, 4], dtype=numpy.uint8)

    cdef long long curr_det, search_det
    cdef unsigned int n_perm
    cdef int search_idx, excite_sign
    cdef double matr_el, ray_num = 0

    for row_det_idx in prange(n_dets - 1, nogil=True, schedule=dynamic):
        thread_idx = threadid()
        curr_det = dets[row_det_idx]
        _sing_ex_symm(curr_det, &occ_orbs[row_det_idx, 0], num_elec, &sing_ex[thread_idx, 0, 0],
                      orb_symm, &n_sing)
        _doub_ex_symm(curr_det, &occ_orbs[row_det_idx, 0], num_elec, &doub_ex[thread_idx, 0, 0],
                      orb_symm, &n_doub)
        for ex_idx in range(n_sing):
            search_det = curr_det ^ (< long long > 1 << sing_ex[thread_idx, ex_idx, 0])
            search_det = search_det ^ (< long long > 1 << sing_ex[thread_idx, ex_idx, 1])
            search_idx = binary_search(&dets[row_det_idx + 1], n_dets - row_det_idx - 1, search_det)
            if search_idx != -1:
                matr_el = _sing_mel(sing_ex[thread_idx, ex_idx, 0], sing_ex[thread_idx, ex_idx, 1],
                                    &occ_orbs[row_det_idx, 0], n_frozen / 2, eris, hcore, num_elec)
                n_perm = bits_between(curr_det, sing_ex[thread_idx, ex_idx, 0], sing_ex[thread_idx, ex_idx, 1])
                if n_perm % 2 == 0:
                    excite_sign = 1
                else:
                    excite_sign = -1
                ray_num += values[row_det_idx] * matr_el * values[search_idx + row_det_idx + 1] * 2 * excite_sign
        for ex_idx in range(n_doub):
            search_det = curr_det ^ (< long long > 1 << doub_ex[thread_idx, ex_idx, 0])
            search_det = search_det ^ (< long long > 1 << doub_ex[thread_idx, ex_idx, 1])
            search_det = search_det ^ (< long long > 1 << doub_ex[thread_idx, ex_idx, 2])
            search_det = search_det ^ (< long long > 1 << doub_ex[thread_idx, ex_idx, 3])
            search_idx = binary_search(&dets[row_det_idx + 1], n_dets - row_det_idx - 1, search_det)
            if search_idx != -1:
                search_det = search_det ^ (< long long > 1 << doub_ex[thread_idx, ex_idx, 3])
                search_det = search_det ^ (< long long > 1 << doub_ex[thread_idx, ex_idx, 2])
                n_perm = bits_between(search_det, doub_ex[thread_idx, ex_idx, 0], doub_ex[thread_idx, ex_idx, 2])
                n_perm = n_perm + bits_between(search_det, doub_ex[thread_idx, ex_idx, 1], doub_ex[thread_idx, ex_idx, 3])
                matr_el = _doub_mel(&doub_ex[thread_idx, ex_idx, 0], eris, n_frozen)
                if n_perm % 2 == 0:
                    excite_sign = 1
                else:
                    excite_sign = -1
                ray_num += matr_el * values[row_det_idx] * values[search_idx + row_det_idx + 1] * 2 * excite_sign
    return ray_num


cdef int binary_search(long long *arr, size_t arr_len, long long target) nogil:
    # searches arr for target, returns -1 if not found
    cdef size_t left = 0
    cdef size_t right = arr_len - 1
    cdef int middle
    if arr[0] > target or arr[right] < target:
        return -1
    while left <= right:
        middle = (left + right) / 2
        if arr[middle] < target:
            left = middle + 1
        elif arr[middle] > target:
            right = middle - 1
        else:
            return middle
    return -1


def diag_matrel(unsigned char[:, :] occ_orbs, double[:, :] hcore,
                double[:, :, :, :] eris, unsigned int n_frozen):
    '''Calculate diagonal matrix elements for a set of Slater determinants.

    Parameters
    ----------
    occ_orbs : (numpy.ndarray, uint8)
        Indices of orbitals occupied in each determinant
    hcore : (numpy.ndarray, float64)
        1-electron integrals from  Hartree-Fock calculation
    eris : (numpy.ndarray, float64)
        2-electron integrals from Hartree-Fock calculation
    n_frozen : (unsigned int)
        number of core electrons frozen in the calculation

    Returns
    -------
    (numpy.ndarray, float64) :
        diagonal matrix elements, including HF energy, and not including
        nuclear repulsion energy.
    '''
    cdef unsigned int n_elec = occ_orbs.shape[1]
    cdef unsigned int num_dets = occ_orbs.shape[0]
    cdef unsigned int n_orb = eris.shape[0]
    cdef numpy.ndarray[numpy.float64_t] matrix_el = numpy.zeros(num_dets, dtype=numpy.float64)
    cdef double matr_sum
    cdef size_t i
    cdef unsigned int j, k, elec_1, elec_2

    for i in prange(num_dets, nogil=True, schedule=static):
        matr_sum = 0.
        for j in range(n_frozen/2):
            matr_sum = matr_sum + hcore[j, j] * 2
            matr_sum = matr_sum + eris[j, j, j, j]
            for k in range(j + 1, n_frozen/2):
                matr_sum = matr_sum + eris[j, k, j, k] * 4
                matr_sum = matr_sum - eris[j, k, k, j] * 2

        for j in range(n_elec/2):
            elec_1 = occ_orbs[i, j] + n_frozen/2
            matr_sum = matr_sum + hcore[elec_1, elec_1]
            for k in range(n_frozen/2):
                matr_sum = matr_sum + eris[elec_1, k, elec_1, k] * 2
                matr_sum = matr_sum - eris[elec_1, k, k, elec_1]
            for k in range(j + 1, n_elec/2):
                elec_2 = occ_orbs[i, k] + n_frozen/2
                matr_sum = matr_sum + eris[elec_1, elec_2, elec_1, elec_2]
                matr_sum = matr_sum - eris[elec_1, elec_2, elec_2, elec_1]
            for k in range(n_elec/2, n_elec):
                elec_2 = occ_orbs[i, k] + n_frozen - n_orb
                matr_sum = matr_sum + eris[elec_1, elec_2, elec_1, elec_2]

        for j in range(n_elec/2, n_elec):
            elec_1 = occ_orbs[i, j] + n_frozen - n_orb
            matr_sum = matr_sum + hcore[elec_1, elec_1]
            for k in range(n_frozen/2):
                matr_sum = matr_sum + eris[elec_1, k, elec_1, k] * 2
                matr_sum = matr_sum - eris[elec_1, k, k, elec_1]
            for k in range(j + 1, n_elec):
                elec_2 = occ_orbs[i, k] + n_frozen - n_orb
                matr_sum = matr_sum + eris[elec_1, elec_2, elec_1, elec_2]
                matr_sum = matr_sum - eris[elec_1, elec_2, elec_2, elec_1]
        matrix_el[i] = matr_sum

    return matrix_el


def excite_signs(unsigned char[:] cre_ops, unsigned char[:] des_ops, long long[:] dets):
    """Calculate the parities of single excitations for an array of bit string
        representations of determinants, i.e. determine the sign of cre_ops^+
        des_ops |bitstrings>. Same as the pyscf subroutine pyscf.fci.cistring.cre_des_sign,
        except can operate on numpy vectors.

        Parameters
        ----------
        cre_ops : (numpy.ndarray, uint8)
            orbital indices of creation operators
        des_ops : (numpy.ndarray, uint8)
            orbital indices of destruction operators
        dets : (numpy.ndarray, int64)
            bit-string representations of determinants
        Returns
        -------
        (numpy.ndarray, int8)
            signs of excitations, +1 or -1
    """
    cdef size_t n_dets = dets.shape[0]
    # cdef unsigned char[16] byte_counts = [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4]
    cdef size_t det_idx
    # cdef unsigned char credes_max, credes_min
    # cdef long long curr_det, mask
    cdef numpy.ndarray[numpy.int8_t] signs = numpy.zeros(n_dets, dtype=numpy.int8)
    cdef int n_perm

    for det_idx in range(n_dets):
        n_perm = bits_between(dets[det_idx], cre_ops[det_idx], des_ops[det_idx])
        if n_perm % 2 == 0:
            signs[det_idx] = 1
        else:
            signs[det_idx] = -1
    return signs


cdef unsigned int bits_between(long long bit_str, unsigned char a, unsigned char b) nogil:
    # count number of 1's between bits a and b in binary representation of bit_str
    cdef unsigned int n_bits = 0
    cdef unsigned char *byte_counts = [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4]
    cdef unsigned char min_bit, max_bit

    if a < b:
        min_bit = a
        max_bit = b
    else:
        max_bit = a
        min_bit = b

    cdef long long mask = (< long long > 1 << max_bit) - (< long long > 1 << (min_bit + 1))
    cdef long long curr_int = (bit_str & mask) >> (min_bit + 1)

    while curr_int != 0:
        n_bits += byte_counts[curr_int & 15]
        curr_int >>= 4

    return n_bits


def all_sing_ex(long long[:] dets, unsigned char[:, :] occ_orbs, unsigned char[:] orb_symm):
    """Generate all spin-alllowed single excitations from an array of Slater determinants.

    Parameters
    ----------
    dets : (numpy.ndarray, int64)
        Bit-string representations of Slater determinants
    occ_orbs : (numpy.ndarray, uint8)
        Orbitals occupied in each determinant
    orb_symm : (numpy.ndarray, uint8)
        Irreducible representations of the spatial orbitals in the basis

    Returns
    -------
    (numpy.ndarray, uint8) :
        Occupied (0th column) and unoccupied (1st column) orbitals for each excitation
    (numpy.ndarray, uint32) :
        Index of the origin determinant of each excitation in the dets array
    """

    cdef size_t det_idx
    cdef size_t num_dets = occ_orbs.shape[0]
    cdef unsigned int num_elec = occ_orbs.shape[1]
    cdef unsigned int num_orb = orb_symm.shape[0]
    cdef unsigned int num_sing_ex = num_elec * (num_orb - num_elec / 2)
    cdef size_t tot_sampl = num_dets * num_sing_ex

    cdef numpy.ndarray[numpy.uint8_t, ndim=2] chosen_orbs = numpy.zeros([tot_sampl, 2],
                                                                        dtype=numpy.uint8)
    cdef numpy.ndarray[numpy.uint32_t] idx_arr = numpy.zeros(tot_sampl, dtype=numpy.uint32)
    cdef size_t num_ex, j, start_idx = 0

    for det_idx in range(num_dets):
        _sing_ex_symm(dets[det_idx], &occ_orbs[det_idx, 0], num_elec, &chosen_orbs[start_idx, 0],
                      orb_symm, &num_ex)
        for j in range(num_ex):
            idx_arr[start_idx + j] = det_idx
        start_idx += num_ex

    return chosen_orbs[:start_idx], idx_arr[:start_idx]


cdef void _sing_ex(long long det, unsigned char[:] occ_orbs, unsigned char *res_arr,
                   unsigned int num_orb):
    """
    Generate all spin-allowed single excitations from a Slater determinant.
    """
    cdef unsigned int num_elec = occ_orbs.shape[0]
    cdef unsigned char i, i_orb, j
    cdef unsigned int idx = 0
    for i in range(num_elec / 2):
        i_orb = occ_orbs[i]
        for j in range(num_orb):
            if not(det & < long long > 1 << j):
                res_arr[idx] = i_orb
                res_arr[idx + 1] = j
                idx += 2
    for i in range(num_elec / 2, num_elec):
        i_orb = occ_orbs[i]
        for j in range(num_orb, 2 * num_orb):
            if not(det & < long long > 1 << j):
                res_arr[idx] = i_orb
                res_arr[idx + 1] = j
                idx += 2


cdef void _sing_ex_symm(long long det, unsigned char *occ_orbs, unsigned int num_elec,
                        unsigned char *res_arr, unsigned char[:] symm, size_t *n_ex) nogil:
    """
    Generate all spin- and symmetry-allowed single excitations from a Slater determinant.
    """
    cdef unsigned char i, i_orb, j
    cdef unsigned int idx = 0
    cdef unsigned int num_orb = symm.shape[0]
    for i in range(num_elec / 2):
        i_orb = occ_orbs[i]
        for j in range(num_orb):
            if not(det & < long long > 1 << j) and (symm[i_orb] ^ symm[j]) == 0:
                res_arr[idx] = i_orb
                res_arr[idx + 1] = j
                idx += 2
    for i in range(num_elec / 2, num_elec):
        i_orb = occ_orbs[i]
        for j in range(num_orb, 2 * num_orb):
            if not(det & < long long > 1 << j) and (symm[i_orb - num_orb] ^ symm[j - num_orb]) == 0:
                res_arr[idx] = i_orb
                res_arr[idx + 1] = j
                idx += 2
    n_ex[0] = idx / 2


cdef void _doub_ex(long long det, unsigned char[:] occ_orbs, unsigned char *res_arr,
                   unsigned int num_orb) nogil:
    """
    Generate all spin-allowed double excitations from a Slater determinant.
    """
    cdef unsigned int num_elec = occ_orbs.shape[0]
    cdef unsigned char i, i_orb, j, j_orb, k, l
    cdef unsigned int idx = 0
    # Different-spin excitations
    for i in range(num_elec / 2):
        i_orb = occ_orbs[i]
        for j in range(num_elec / 2, num_elec):
            j_orb = occ_orbs[j]
            for k in range(num_orb):
                if not(det & (< long long > 1 << k)):
                    for l in range(num_orb, 2 * num_orb):
                        if not(det & (< long long > 1 << l)):
                            res_arr[idx] = i_orb
                            res_arr[idx + 1] = j_orb
                            res_arr[idx + 2] = k
                            res_arr[idx + 3] = l
                            idx += 4
    # Same-spin (up) excitations
    for i in range(num_elec / 2):
        i_orb = occ_orbs[i]
        for j in range(i + 1, num_elec / 2):
            j_orb = occ_orbs[j]
            for k in range(num_orb):
                if not(det & (< long long > 1 << k)):
                    for l in range(k + 1, num_orb):
                        if not(det & (< long long > 1 << l)):
                            res_arr[idx] = i_orb
                            res_arr[idx + 1] = j_orb
                            res_arr[idx + 2] = k
                            res_arr[idx + 3] = l
                            idx += 4
    # Same-spin (down) excitations
    for i in range(num_elec / 2, num_elec):
        i_orb = occ_orbs[i]
        for j in range(i + 1, num_elec):
            j_orb = occ_orbs[j]
            for k in range(num_orb, 2 * num_orb):
                if not(det & (< long long > 1 << k)):
                    for l in range(k + 1, 2 * num_orb):
                        if not(det & (< long long > 1 << l)):
                            res_arr[idx] = i_orb
                            res_arr[idx + 1] = j_orb
                            res_arr[idx + 2] = k
                            res_arr[idx + 3] = l
                            idx += 4


def all_doub_ex(long long[:] dets, unsigned char[:, :] occ_orbs, unsigned char[:] orb_symm):
    """Generate all spin- and symmetry-alllowed double excitations from an array of Slater determinants.

    Parameters
    ----------
    dets : (numpy.ndarray, int64)
        Bit-string representations of Slater determinants
    occ_orbs : (numpy.ndarray, uint8)
        Orbitals occupied in each determinant
    orb_symm : (numpy.ndarray, uint8)
        Irreducible representations of the spatial orbitals in the basis

    Returns
    -------
    (numpy.ndarray, uint8) :
        Occupied (0th and 1st columns) and unoccupied (2nd and 3rd columns) orbitals for each excitation
    (numpy.ndarray, uint32) :
        Index of the origin determinant of each excitation in the dets array
    """

    cdef size_t det_idx
    cdef unsigned long num_dets = occ_orbs.shape[0]
    cdef unsigned int num_elec = occ_orbs.shape[1]
    cdef unsigned int num_orb = orb_symm.shape[0]
    cdef unsigned int n_unocc = num_orb - num_elec / 2
    cdef unsigned int n_same = num_elec * (num_elec / 2 - 1) / 2 * n_unocc * (n_unocc - 1) / 2
    cdef unsigned int n_diff = num_elec / 2 * num_elec / 2 * n_unocc ** 2
    cdef unsigned int tot_sampl = num_dets * (n_same + n_diff)

    cdef numpy.ndarray[numpy.uint8_t, ndim=2] chosen_orbs = numpy.zeros([tot_sampl, 4],
                                                                        dtype=numpy.uint8)
    cdef numpy.ndarray[numpy.uint32_t] idx_arr = numpy.zeros(tot_sampl, dtype=numpy.uint32)

    cdef size_t j, num_ex, start_idx = 0

    for det_idx in range(num_dets):
        _doub_ex_symm(dets[det_idx], &occ_orbs[det_idx, 0], num_elec, &chosen_orbs[start_idx, 0], orb_symm, &num_ex)

        for j in range(num_ex):
            idx_arr[start_idx + j] = det_idx
        start_idx += num_ex

    return chosen_orbs[:start_idx], idx_arr[:start_idx]


cdef void _doub_ex_symm(long long det, unsigned char *occ_orbs, unsigned int num_elec,
                        unsigned char *res_arr, unsigned char[:] symm, size_t *n_ex) nogil:
    """
    Generate all spin- and symmetry allowed double excitations from a Slater determinant.
    """
    cdef unsigned char i, i_orb, j, j_orb, k, l
    cdef unsigned int idx = 0
    cdef unsigned int num_orb = symm.shape[0]
    # Different-spin excitations
    for i in range(num_elec / 2):
        i_orb = occ_orbs[i]
        for j in range(num_elec / 2, num_elec):
            j_orb = occ_orbs[j]
            for k in range(num_orb):
                if not(det & (< long long > 1 << k)):
                    for l in range(num_orb, 2 * num_orb):
                        if not(det & (< long long > 1 << l)) and (symm[i_orb] ^ symm[j_orb - num_orb] ^ symm[k] ^ symm[l - num_orb]) == 0:
                            res_arr[idx] = i_orb
                            res_arr[idx + 1] = j_orb
                            res_arr[idx + 2] = k
                            res_arr[idx + 3] = l
                            idx += 4
    # Same-spin (up) excitations
    for i in range(num_elec / 2):
        i_orb = occ_orbs[i]
        for j in range(i + 1, num_elec / 2):
            j_orb = occ_orbs[j]
            for k in range(num_orb):
                if not(det & (< long long > 1 << k)):
                    for l in range(k + 1, num_orb):
                        if not(det & (< long long > 1 << l)) and (symm[i_orb] ^ symm[j_orb] ^ symm[k] ^ symm[l]) == 0:
                            res_arr[idx] = i_orb
                            res_arr[idx + 1] = j_orb
                            res_arr[idx + 2] = k
                            res_arr[idx + 3] = l
                            idx += 4
    # Same-spin (down) excitations
    for i in range(num_elec / 2, num_elec):
        i_orb = occ_orbs[i]
        for j in range(i + 1, num_elec):
            j_orb = occ_orbs[j]
            for k in range(num_orb, 2 * num_orb):
                if not(det & (< long long > 1 << k)):
                    for l in range(k + 1, 2 * num_orb):
                        if not(det & (< long long > 1 << l)) and (symm[i_orb - num_orb] ^
                                                                  symm[j_orb - num_orb] ^
                                                                  symm[k - num_orb] ^ symm[l - num_orb]) == 0:
                            res_arr[idx] = i_orb
                            res_arr[idx + 1] = j_orb
                            res_arr[idx + 2] = k
                            res_arr[idx + 3] = l
                            idx += 4
    n_ex[0] = idx / 4

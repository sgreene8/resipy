#cython: boundscheck=False, wraparound=False, cdivision=True
"""
Cython-based utilities for manipulating bit-string representations of Slater
determinants and calculating FCI matrix elements. See fci_utils.py for more
information.
"""

import fci_utils
import numpy
cimport numpy
from cython.parallel import prange, threadid

def gen_orb_lists(long long[:] dets, unsigned int num_orb, unsigned int num_elec,
                  unsigned char[:] lookup_nums, unsigned char[:, :] lookup_idx):
    """Generate arrays of indices of occupied orbitals from bit string 
    representations of Slater determinants, following procedure in Sec. 3.1 of
    Booth et al. (2014).

    Parameters
    ----------
    dets : (numpy.ndarray, int64)
        array of bit strings to parse. all must have the same number of occupied
        orbitals,and the same number unoccupied
    num_orb : (unsigned int)
        number of spin orbitals in the basis
    num_elec : (unsigned int)
        number of electrons in the system
    lookup_nums : (numpy.ndarray, uint8)
        the first of the lookup tables generated by fci_utils.gen_byte_table()
    lookup_idx : (numpy.ndarray, uint8)
        the second of the lookup tables generated by fci_utils.gen_byte_table()

    Returns
    -------
    (numpy.ndarray, uint8) : 
        indices of occupied orbitals for each determinant
    """
    
    cdef unsigned int n_dets = dets.shape[0]
    cdef numpy.ndarray[numpy.uint8_t, ndim=2] occ_orbs = numpy.zeros([n_dets, num_elec], 
                                                                      dtype=numpy.uint8)
    cdef unsigned int det_idx, byte_idx, elec_idx
    cdef long long curr_det, mask = 255
    cdef unsigned int num_bytes = num_orb / 8
    cdef unsigned char n_elec, det_byte, bit_idx
    
    if num_orb % 8 > 0:
        num_bytes += 1
    
    for det_idx in range(n_dets):
        curr_det = dets[det_idx]
        elec_idx = 0
        for byte_idx in range(num_bytes):
            det_byte = curr_det & mask
            n_elec = lookup_nums[det_byte]
            for bit_idx in range(n_elec):
                occ_orbs[det_idx, elec_idx + bit_idx] = (8 * byte_idx + 
                                                         lookup_idx[det_byte, 
                                                                    bit_idx])
            elec_idx += n_elec
            curr_det >>= 8
            
    return occ_orbs


def single_dets_matrel(numpy.ndarray[numpy.int64_t] dets, 
                       numpy.ndarray[numpy.uint8_t, ndim=2] ex_orbs,
                       double[:,:,:,:] eris, double[:,:] hcore,
                       unsigned char[:,:] occ_orbs, unsigned int n_frozen):
    '''Calculate matrix elements and resulting determinants for single
    excitations.
    
    Parameters
    ----------
    dets : (numpy.ndarray, int64)
        bit string representations of origin determinants from which to excite
    ex_orbs : (numpy.ndarray, uint8)
        indices of occupied (0th column) and unoccupied (1st column) orbitals
        involved in the excitation
    eris : (numpy.ndarray, float64)
        2-electron integrals from Hartree-Fock calculation
    hcore : (numpy.ndarray, float64)
        1-electron integrals from  Hartree-Fock calculation
    occ_orbs : (numpy.ndarray, uint8)
        orbitals occupied in each origin determinant
    n_frozen : (unsigned int)
        number of core electrons frozen in the calculation
    '''
    cdef unsigned int n_elec = occ_orbs.shape[1]
    cdef unsigned int n_dets = dets.shape[0]
    cdef unsigned int n_orb = eris.shape[0]
    cdef numpy.ndarray[numpy.float64_t] matrix_el = numpy.zeros(n_dets, 
                                                            dtype=numpy.float64)
    cdef double matr_sum
    cdef unsigned int i, j, occ_spa, unocc_spa, occ_spin
    cdef unsigned int eris_idx = 0
    cdef unsigned int half_frz = n_frozen / 2
    
    for i in prange(n_dets, nogil=True, schedule=static):
        # spatial index of occupied & unoccupied orbitals
        occ_spa = (ex_orbs[i, 0] % (n_orb - half_frz)) + half_frz
        unocc_spa = (ex_orbs[i, 1] % (n_orb - half_frz)) + half_frz
        occ_spin = ex_orbs[i, 0] / (n_orb - half_frz)
        matr_sum = hcore[occ_spa, unocc_spa]
        for j in range(half_frz):
            # double-count coulomb term
            matr_sum = matr_sum + eris[occ_spa, j, unocc_spa, j] * 2
            # single-count exchange term
            matr_sum = matr_sum - eris[occ_spa, j, j, unocc_spa]
        for j in range(n_elec / 2):
            matr_sum = matr_sum + eris[occ_spa, occ_orbs[i, j] + half_frz, 
                                       unocc_spa, occ_orbs[i, j] + half_frz]
            if occ_spin == 0:
                matr_sum = matr_sum - eris[occ_spa, occ_orbs[i, j] + half_frz,
                                           occ_orbs[i, j] + half_frz, unocc_spa]
        for j in range(n_elec / 2, n_elec):
            matr_sum = matr_sum + eris[occ_spa, occ_orbs[i, j] - n_orb + 
                                       n_frozen, unocc_spa, occ_orbs[i, j] - 
                                       n_orb + n_frozen]
            if occ_spin == 1:
                matr_sum = matr_sum - eris[occ_spa, occ_orbs[i, j] - n_orb + 
                                           n_frozen, occ_orbs[i, j] - n_orb + 
                                           n_frozen, unocc_spa]
        matrix_el[i] = matr_sum
    
    matrix_el *= fci_utils.excite_signs(ex_orbs[:, 1], ex_orbs[:, 0], dets)
    one = numpy.ones(1, dtype=numpy.int64)
    excited_dets = dets ^ (one << ex_orbs[:, 0])
    excited_dets ^= one << ex_orbs[:, 1]
    return excited_dets, matrix_el


def diag_matrel(unsigned char[:,:] occ_orbs, double[:,:] hcore, 
               double[:,:,:,:] eris, unsigned int n_frozen):
    '''Calculate diagonal matrix elements for a set of Slater determinants.
    
    Parameters
    ----------
    occ_orbs : (numpy.ndarray, uint8)
        Indices of orbitals occupied in each determinant
    hcore : (numpy.ndarray, float64)
        1-electron integrals from  Hartree-Fock calculation
    eris : (numpy.ndarray, float64)
        2-electron integrals from Hartree-Fock calculation
    n_frozen : (unsigned int)
        number of core electrons frozen in the calculation
    
    Returns
    -------
    (numpy.ndarray, float64) : 
        diagonal matrix elements, including HF energy, and not including
        nuclear repulsion energy.
    '''
    cdef unsigned int n_elec = occ_orbs.shape[1]
    cdef unsigned int num_dets = occ_orbs.shape[0]
    cdef unsigned int n_orb = eris.shape[0]
    cdef numpy.ndarray[numpy.float64_t] matrix_el = numpy.zeros(num_dets, dtype=numpy.float64)
    cdef double matr_sum
    cdef unsigned int i, j, k, elec_1, elec_2
    
    for i in prange(num_dets, nogil=True, schedule=static):
        matr_sum = 0.
        for j in range(n_frozen/2):
            matr_sum = matr_sum + hcore[j, j] * 2
            matr_sum = matr_sum + eris[j, j, j, j]
            for k in range(j + 1, n_frozen/2):
                matr_sum = matr_sum + eris[j, k, j, k] * 4
                matr_sum = matr_sum - eris[j, k, k, j] * 2
        
        for j in range(n_elec/2):
            elec_1 = occ_orbs[i, j] + n_frozen/2
            matr_sum = matr_sum + hcore[elec_1, elec_1]
            for k in range(n_frozen/2):
                matr_sum = matr_sum + eris[elec_1, k, elec_1, k] * 2
                matr_sum = matr_sum - eris[elec_1, k, k, elec_1]
            for k in range(j + 1, n_elec/2):
                elec_2 = occ_orbs[i, k] + n_frozen/2
                matr_sum = matr_sum + eris[elec_1, elec_2, elec_1, elec_2]
                matr_sum = matr_sum - eris[elec_1, elec_2, elec_2, elec_1]
            for k in range(n_elec/2, n_elec):
                elec_2 = occ_orbs[i, k] + n_frozen - n_orb
                matr_sum = matr_sum + eris[elec_1, elec_2, elec_1, elec_2]
        
        for j in range(n_elec/2, n_elec):
            elec_1 = occ_orbs[i, j] + n_frozen - n_orb
            matr_sum = matr_sum + hcore[elec_1, elec_1]
            for k in range(n_frozen/2):
                matr_sum = matr_sum + eris[elec_1, k, elec_1, k] * 2
                matr_sum = matr_sum - eris[elec_1, k, k, elec_1]
            for k in range(j + 1, n_elec):
                elec_2 = occ_orbs[i, k] + n_frozen - n_orb
                matr_sum = matr_sum + eris[elec_1, elec_2, elec_1, elec_2]
                matr_sum = matr_sum - eris[elec_1, elec_2, elec_2, elec_1]
        matrix_el[i] = matr_sum
    
    return matrix_el


def all_sing_ex(long long[:] dets, unsigned char[:, :] occ_orbs, unsigned char num_orb):
    """Generate all spin-alllowed single excitations from an array of Slater determinants.
    
    Parameters
    ----------
    dets : (numpy.ndarray, int64)
        Bit-string representations of Slater determinants
    occ_orbs : (numpy.ndarray, uint8)
        Orbitals occupied in each determinant
    num_orb : (unsigned int)
        Number of spatial orbitals in the basis.
    
    Returns
    -------
    (numpy.ndarray, uint8) :
        Occupied (0th column) and unoccupied (1st column) orbitals for each excitation
    """

    cdef unsigned int det_idx
    cdef unsigned long num_dets = occ_orbs.shape[0]
    cdef unsigned int num_elec = occ_orbs.shape[1]
    cdef unsigned int num_sing_ex = num_elec * (num_orb - num_elec / 2)
    cdef unsigned int tot_sampl = num_dets * num_sing_ex
    
    cdef numpy.ndarray[numpy.uint8_t, ndim=2] chosen_orbs = numpy.zeros([tot_sampl, 2], 
                                                                        dtype=numpy.uint8)
    for det_idx in range(num_dets):
        _sing_ex(dets[det_idx], occ_orbs[det_idx], &chosen_orbs[det_idx * num_sing_ex, 0],
                 num_orb)
    return chosen_orbs


cdef void _sing_ex(long long det, unsigned char[:] occ_orbs, unsigned char *res_arr,
                    unsigned int num_orb):
    """
    Generate all spin-allowed single excitations from a Slater determinant.
    """
    cdef unsigned int num_elec = occ_orbs.shape[0]
    cdef unsigned char i, i_orb, j
    cdef unsigned int idx = 0
    for i in range(num_elec / 2):
        i_orb = occ_orbs[i]
        for j in range(num_orb):
            if not(det & <long long> 1 << j):
                res_arr[idx] = i_orb
                res_arr[idx + 1] = j
                idx += 2
    for i in range(num_elec / 2, num_elec):
        i_orb = occ_orbs[i]
        for j in range(num_orb, 2 * num_orb):
            if not(det & <long long> 1 << j):
                res_arr[idx] = i_orb
                res_arr[idx + 1] = j
                idx += 2


def all_doub_ex(long long[:] dets, unsigned char[:, :] occ_orbs, unsigned char num_orb):
    """Generate all spin-alllowed double excitations from an array of Slater determinants.
    
    Parameters
    ----------
    dets : (numpy.ndarray, int64)
        Bit-string representations of Slater determinants
    occ_orbs : (numpy.ndarray, uint8)
        Orbitals occupied in each determinant
    num_orb : (unsigned int)
        Number of spatial orbitals in the basis.
    
    Returns
    -------
    (numpy.ndarray, uint8) :
        Occupied (0th and 1st columns) and unoccupied (2nd and 3rd columns) orbitals for each excitation
    """

    cdef unsigned int det_idx
    cdef unsigned long num_dets = occ_orbs.shape[0]
    cdef unsigned int num_elec = occ_orbs.shape[1]
    cdef unsigned int n_unocc = num_orb - num_elec / 2
    cdef unsigned int n_same = num_elec * (num_elec / 2 - 1) / 2 * n_unocc * (n_unocc - 1) / 2
    cdef unsigned int n_diff = num_elec / 2 * num_elec / 2 * n_unocc ** 2
    cdef unsigned int tot_sampl = num_dets * (n_same + n_diff)
    
    cdef numpy.ndarray[numpy.uint8_t, ndim=2] chosen_orbs = numpy.zeros([tot_sampl, 4], 
                                                                          dtype=numpy.uint8)
    for det_idx in range(num_dets):
        _doub_ex(dets[det_idx], occ_orbs[det_idx], &chosen_orbs[det_idx * (n_same + 
                                                                n_diff), 0], num_orb)
    return chosen_orbs

cdef void _doub_ex(long long det, unsigned char[:] occ_orbs, unsigned char *res_arr,
                    unsigned int num_orb):
    """
    Generate all spin-allowed double excitations from a Slater determinant.
    """
    cdef unsigned int num_elec = occ_orbs.shape[0]
    cdef unsigned char i, i_orb, j, j_orb, k, l
    cdef unsigned int idx = 0
    # Different-spin excitations
    for i in range(num_elec / 2):
        i_orb = occ_orbs[i]
        for j in range(num_elec / 2, num_elec):
            j_orb = occ_orbs[j]
            for k in range(num_orb):
                if not(det & (<long long> 1 << k)):
                    for l in range(num_orb, 2 * num_orb):
                        if not(det & (<long long> 1 << l)):
                            res_arr[idx] = i_orb
                            res_arr[idx + 1] = j_orb
                            res_arr[idx + 2] = k
                            res_arr[idx + 3] = l
                            idx += 4
    # Same-spin (up) excitations
    for i in range(num_elec / 2):
        i_orb = occ_orbs[i]
        for j in range(i + 1, num_elec / 2):
            j_orb = occ_orbs[j]
            for k in range(num_orb):
                if not(det & (<long long> 1 << k)):
                    for l in range(k + 1, num_orb):
                        if not(det & (<long long> 1 << l)):
                            res_arr[idx] = i_orb
                            res_arr[idx + 1] = j_orb
                            res_arr[idx + 2] = k
                            res_arr[idx + 3] = l
                            idx += 4
    # Same-spin (down) excitations
    for i in range(num_elec / 2, num_elec):
        i_orb = occ_orbs[i]
        for j in range(i + 1, num_elec):
            j_orb = occ_orbs[j]
            for k in range(num_orb, 2 * num_orb):
                if not(det & (<long long> 1 << k)):
                    for l in range(k + 1, 2 * num_orb):
                        if not(det & (<long long> 1 << l)):
                            res_arr[idx] = i_orb
                            res_arr[idx + 1] = j_orb
                            res_arr[idx + 2] = k
                            res_arr[idx + 3] = l
                            idx += 4


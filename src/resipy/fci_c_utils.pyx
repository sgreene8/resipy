#cython: boundscheck=False, wraparound=False, cdivision=True
"""
Cython-based utilities for manipulating bit-string representations of Slater
determinants and calculating FCI matrix elements. See fci_utils.py for more
information.
"""

import numpy
cimport numpy
from cython.parallel import prange

def gen_orb_lists(long long[:] dets, unsigned int num_orb, unsigned int num_elec,
                  unsigned char[:] lookup_nums, unsigned char[:, :] lookup_idx):
    """Generate arrays of indices of occupied orbitals from bit string 
    representations of Slater determinants, following procedure in Sec. 3.1 of
    Booth et al. (2014).

    Parameters
    ----------
    dets : (numpy.ndarray, int64)
        array of bit strings to parse. all must have the same number of occupied
        orbitals,and the same number unoccupied
    num_orb : (unsigned int)
        number of spin orbitals in the basis
    num_elec : (unsigned int)
        number of electrons in the system
    lookup_nums : (numpy.ndarray, uint8)
        the first of the lookup tables generated by fci_utils.gen_byte_table()
    lookup_idx : (numpy.ndarray, uint8)
        the second of the lookup tables generated by fci_utils.gen_byte_table()

    Returns
    -------
    (numpy.ndarray, uint8) : 
        indices of occupied orbitals for each determinant
    """
    
    cdef size_t n_dets = dets.shape[0]
    cdef numpy.ndarray[numpy.uint8_t, ndim=2] occ_orbs = numpy.zeros([n_dets, num_elec], 
                                                                      dtype=numpy.uint8)
    cdef unsigned int byte_idx, elec_idx
    cdef size_t det_idx
    cdef long long curr_det, mask = 255
    cdef unsigned int num_bytes = num_orb / 8
    cdef unsigned char n_elec, det_byte, bit_idx
    
    if num_orb % 8 > 0:
        num_bytes += 1
    
    for det_idx in prange(n_dets, nogil=True, schedule=static):
        curr_det = dets[det_idx]
        elec_idx = 0
        for byte_idx in range(num_bytes):
            det_byte = curr_det & mask
            n_elec = lookup_nums[det_byte]
            for bit_idx in range(n_elec):
                occ_orbs[det_idx, elec_idx + bit_idx] = (8 * byte_idx + 
                                                         lookup_idx[det_byte, 
                                                                    bit_idx])
            elec_idx = elec_idx + n_elec
            curr_det = curr_det >> 8
            
    return occ_orbs


def doub_matr_el_nosgn(unsigned char[:, :] chosen_idx, double[:, :, :, :] eris, 
                       unsigned int n_frozen):
    """Calculate the matrix elements for double excitations without accounting
        for the parity of the excitations.

        Parameters
        ----------
        chosen_idx : (numpy.ndarray, unsigned int)
            the chosen indices of the two occupied orbitals (0th and 1st
            columns) and two virtual orbitals (2nd and 3rd columns) in each
            excitation
        eris : (numpy.ndarray, float)
            4-D array of 2-electron integrals in spatial MO basis
        n_frozen : (unsigned int)
            number of core electrons frozen in the calculation

        Returns
        -------
        (numpy.ndarray, float)
            matrix elements for all excitations
    """
    cdef unsigned int adj_n_orb = eris.shape[0] - n_frozen / 2
    cdef size_t n_samp = chosen_idx.shape[0]
    cdef numpy.ndarray[numpy.float64_t] matrix_el = numpy.zeros(n_samp)
    cdef size_t samp_idx
    cdef unsigned char sp0, sp1, sp2, sp3
    cdef int same_sp
    cdef double mat_el

    for samp_idx in prange(n_samp, nogil=True, schedule=static):
        sp0 = chosen_idx[samp_idx, 0]
        sp1 = chosen_idx[samp_idx, 1]
        same_sp = sp0 / adj_n_orb == sp1 / adj_n_orb
        sp0 = (sp0 % adj_n_orb) + n_frozen / 2
        sp1 = (sp1 % adj_n_orb) + n_frozen / 2
        sp2 = (chosen_idx[samp_idx, 2] % adj_n_orb) + n_frozen / 2
        sp3 = (chosen_idx[samp_idx, 3] % adj_n_orb) + n_frozen / 2

        mat_el = eris[sp0, sp1, sp2, sp3]
        if same_sp:
            mat_el = mat_el - eris[sp0, sp1, sp3, sp2]
        matrix_el[samp_idx] = mat_el

    return matrix_el


def single_dets_matrel_nosgn(numpy.ndarray[numpy.int64_t] dets, 
                       numpy.ndarray[numpy.uint8_t, ndim=2] ex_orbs,
                       double[:,:,:,:] eris, double[:,:] hcore,
                       unsigned char[:,:] occ_orbs, unsigned int n_frozen):
    '''Calculate matrix elements and resulting determinants for single
    excitations.
    
    Parameters
    ----------
    dets : (numpy.ndarray, int64)
        bit string representations of origin determinants from which to excite
    ex_orbs : (numpy.ndarray, uint8)
        indices of occupied (0th column) and unoccupied (1st column) orbitals
        involved in the excitation
    eris : (numpy.ndarray, float64)
        2-electron integrals from Hartree-Fock calculation
    hcore : (numpy.ndarray, float64)
        1-electron integrals from  Hartree-Fock calculation
    occ_orbs : (numpy.ndarray, uint8)
        orbitals occupied in each origin determinant
    n_frozen : (unsigned int)
        number of core electrons frozen in the calculation
    '''
    cdef unsigned int n_elec = occ_orbs.shape[1]
    cdef size_t n_dets = dets.shape[0]
    cdef unsigned int n_orb = eris.shape[0]
    cdef numpy.ndarray[numpy.float64_t] matrix_el = numpy.zeros(n_dets, 
                                                            dtype=numpy.float64)
    cdef double matr_sum
    cdef size_t i
    cdef unsigned int j, occ_spa, unocc_spa, occ_spin
    cdef unsigned int eris_idx = 0
    cdef unsigned int half_frz = n_frozen / 2
    
    for i in prange(n_dets, nogil=True, schedule=static):
        # spatial index of occupied & unoccupied orbitals
        occ_spa = (ex_orbs[i, 0] % (n_orb - half_frz)) + half_frz
        unocc_spa = (ex_orbs[i, 1] % (n_orb - half_frz)) + half_frz
        occ_spin = ex_orbs[i, 0] / (n_orb - half_frz)
        matr_sum = hcore[occ_spa, unocc_spa]
        for j in range(half_frz):
            # double-count coulomb term
            matr_sum = matr_sum + eris[occ_spa, j, unocc_spa, j] * 2
            # single-count exchange term
            matr_sum = matr_sum - eris[occ_spa, j, j, unocc_spa]
        for j in range(n_elec / 2):
            matr_sum = matr_sum + eris[occ_spa, occ_orbs[i, j] + half_frz, 
                                       unocc_spa, occ_orbs[i, j] + half_frz]
            if occ_spin == 0:
                matr_sum = matr_sum - eris[occ_spa, occ_orbs[i, j] + half_frz,
                                           occ_orbs[i, j] + half_frz, unocc_spa]
        for j in range(n_elec / 2, n_elec):
            matr_sum = matr_sum + eris[occ_spa, occ_orbs[i, j] - n_orb + 
                                       n_frozen, unocc_spa, occ_orbs[i, j] - 
                                       n_orb + n_frozen]
            if occ_spin == 1:
                matr_sum = matr_sum - eris[occ_spa, occ_orbs[i, j] - n_orb + 
                                           n_frozen, occ_orbs[i, j] - n_orb + 
                                           n_frozen, unocc_spa]
        matrix_el[i] = matr_sum

    one = numpy.ones(1, dtype=numpy.int64)
    excited_dets = dets ^ (one << ex_orbs[:, 0])
    excited_dets ^= one << ex_orbs[:, 1]
    return excited_dets, matrix_el


def diag_matrel(unsigned char[:,:] occ_orbs, double[:,:] hcore, 
               double[:,:,:,:] eris, unsigned int n_frozen):
    '''Calculate diagonal matrix elements for a set of Slater determinants.
    
    Parameters
    ----------
    occ_orbs : (numpy.ndarray, uint8)
        Indices of orbitals occupied in each determinant
    hcore : (numpy.ndarray, float64)
        1-electron integrals from  Hartree-Fock calculation
    eris : (numpy.ndarray, float64)
        2-electron integrals from Hartree-Fock calculation
    n_frozen : (unsigned int)
        number of core electrons frozen in the calculation
    
    Returns
    -------
    (numpy.ndarray, float64) : 
        diagonal matrix elements, including HF energy, and not including
        nuclear repulsion energy.
    '''
    cdef unsigned int n_elec = occ_orbs.shape[1]
    cdef unsigned int num_dets = occ_orbs.shape[0]
    cdef unsigned int n_orb = eris.shape[0]
    cdef numpy.ndarray[numpy.float64_t] matrix_el = numpy.zeros(num_dets, dtype=numpy.float64)
    cdef double matr_sum
    cdef size_t i
    cdef unsigned int j, k, elec_1, elec_2
    
    for i in prange(num_dets, nogil=True, schedule=static):
        matr_sum = 0.
        for j in range(n_frozen/2):
            matr_sum = matr_sum + hcore[j, j] * 2
            matr_sum = matr_sum + eris[j, j, j, j]
            for k in range(j + 1, n_frozen/2):
                matr_sum = matr_sum + eris[j, k, j, k] * 4
                matr_sum = matr_sum - eris[j, k, k, j] * 2
        
        for j in range(n_elec/2):
            elec_1 = occ_orbs[i, j] + n_frozen/2
            matr_sum = matr_sum + hcore[elec_1, elec_1]
            for k in range(n_frozen/2):
                matr_sum = matr_sum + eris[elec_1, k, elec_1, k] * 2
                matr_sum = matr_sum - eris[elec_1, k, k, elec_1]
            for k in range(j + 1, n_elec/2):
                elec_2 = occ_orbs[i, k] + n_frozen/2
                matr_sum = matr_sum + eris[elec_1, elec_2, elec_1, elec_2]
                matr_sum = matr_sum - eris[elec_1, elec_2, elec_2, elec_1]
            for k in range(n_elec/2, n_elec):
                elec_2 = occ_orbs[i, k] + n_frozen - n_orb
                matr_sum = matr_sum + eris[elec_1, elec_2, elec_1, elec_2]
        
        for j in range(n_elec/2, n_elec):
            elec_1 = occ_orbs[i, j] + n_frozen - n_orb
            matr_sum = matr_sum + hcore[elec_1, elec_1]
            for k in range(n_frozen/2):
                matr_sum = matr_sum + eris[elec_1, k, elec_1, k] * 2
                matr_sum = matr_sum - eris[elec_1, k, k, elec_1]
            for k in range(j + 1, n_elec):
                elec_2 = occ_orbs[i, k] + n_frozen - n_orb
                matr_sum = matr_sum + eris[elec_1, elec_2, elec_1, elec_2]
                matr_sum = matr_sum - eris[elec_1, elec_2, elec_2, elec_1]
        matrix_el[i] = matr_sum
    
    return matrix_el


def excite_signs(unsigned char[:] cre_ops, unsigned char[:] des_ops, long long[:] dets):
    """Calculate the parities of single excitations for an array of bit string
        representations of determinants, i.e. determine the sign of cre_ops^+
        des_ops |bitstrings>. Same as the pyscf subroutine pyscf.fci.cistring.cre_des_sign,
        except can operate on numpy vectors.

        Parameters
        ----------
        cre_ops : (numpy.ndarray, uint8)
            orbital indices of creation operators
        des_ops : (numpy.ndarray, uint8)
            orbital indices of destruction operators
        dets : (numpy.ndarray, int64)
            bit-string representations of determinants
        Returns
        -------
        (numpy.ndarray, int8)
            signs of excitations, +1 or -1
    """
    cdef size_t n_dets = dets.shape[0]
    cdef unsigned char[16] byte_counts = [0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4]
    cdef size_t det_idx
    cdef unsigned char credes_max, credes_min
    cdef long long curr_det, mask
    cdef numpy.ndarray[numpy.int8_t] signs = numpy.zeros(n_dets, dtype=numpy.int8)
    cdef int n_perm

    for det_idx in range(n_dets):
        if cre_ops[det_idx] < des_ops[det_idx]:
            credes_min = cre_ops[det_idx]
            credes_max = des_ops[det_idx]
        else:
            credes_max = cre_ops[det_idx]
            credes_min = des_ops[det_idx]

        n_perm = 0
        mask = (< long long > 1 << credes_max) - (< long long > 1 << (credes_min + 1))
        curr_det = (dets[det_idx] & mask) >> (credes_min + 1)

        while curr_det > 0:
            n_perm += byte_counts[curr_det & 15]
            curr_det = curr_det >> 4
        if n_perm % 2 == 0:
            signs[det_idx] = 1
        else:
            signs[det_idx] = -1
    return signs


def all_sing_ex(long long[:] dets, unsigned char[:, :] occ_orbs, numpy.ndarray[numpy.uint8_t] orb_symm):
    """Generate all spin-alllowed single excitations from an array of Slater determinants.
    
    Parameters
    ----------
    dets : (numpy.ndarray, int64)
        Bit-string representations of Slater determinants
    occ_orbs : (numpy.ndarray, uint8)
        Orbitals occupied in each determinant
    orb_symm : (numpy.ndarray, uint8)
        Irreducible representations of the spatial orbitals in the basis
    
    Returns
    -------
    (numpy.ndarray, uint8) :
        Occupied (0th column) and unoccupied (1st column) orbitals for each excitation
    (numpy.ndarray, uint32) :
        Index of the origin determinant of each excitation in the dets array
    """

    cdef size_t det_idx
    cdef size_t num_dets = occ_orbs.shape[0]
    cdef unsigned int num_elec = occ_orbs.shape[1]
    cdef unsigned int num_orb = orb_symm.shape[0]
    cdef unsigned int num_sing_ex = num_elec * (num_orb - num_elec / 2)
    cdef size_t tot_sampl = num_dets * num_sing_ex
    
    cdef numpy.ndarray[numpy.uint8_t, ndim=2] chosen_orbs = numpy.zeros([tot_sampl, 2], 
                                                                        dtype=numpy.uint8)
    for det_idx in range(num_dets):
        _sing_ex(dets[det_idx], occ_orbs[det_idx], &chosen_orbs[det_idx * num_sing_ex, 0],
                 num_orb)

    idx_arr = numpy.arange(num_dets, dtype=numpy.uint32)
    idx_arr.shape = (-1, 1)
    idx_arr = numpy.tile(idx_arr, (1, num_sing_ex))
    idx_arr.shape = (-1)

    successes = (orb_symm[chosen_orbs[:, 0] % num_orb] == 
                 orb_symm[chosen_orbs[:, 1] % num_orb])

    return chosen_orbs[successes], idx_arr[successes]


cdef void _sing_ex(long long det, unsigned char[:] occ_orbs, unsigned char *res_arr,
                    unsigned int num_orb):
    """
    Generate all spin-allowed single excitations from a Slater determinant.
    """
    cdef unsigned int num_elec = occ_orbs.shape[0]
    cdef unsigned char i, i_orb, j
    cdef unsigned int idx = 0
    for i in range(num_elec / 2):
        i_orb = occ_orbs[i]
        for j in range(num_orb):
            if not(det & <long long> 1 << j):
                res_arr[idx] = i_orb
                res_arr[idx + 1] = j
                idx += 2
    for i in range(num_elec / 2, num_elec):
        i_orb = occ_orbs[i]
        for j in range(num_orb, 2 * num_orb):
            if not(det & <long long> 1 << j):
                res_arr[idx] = i_orb
                res_arr[idx + 1] = j
                idx += 2


def all_doub_ex(long long[:] dets, unsigned char[:, :] occ_orbs, numpy.ndarray[numpy.uint8_t] orb_symm):
    """Generate all spin-alllowed double excitations from an array of Slater determinants.
    
    Parameters
    ----------
    dets : (numpy.ndarray, int64)
        Bit-string representations of Slater determinants
    occ_orbs : (numpy.ndarray, uint8)
        Orbitals occupied in each determinant
    orb_symm : (numpy.ndarray, uint8)
        Irreducible representations of the spatial orbitals in the basis
    
    Returns
    -------
    (numpy.ndarray, uint8) :
        Occupied (0th and 1st columns) and unoccupied (2nd and 3rd columns) orbitals for each excitation
    (numpy.ndarray, uint32) :
        Index of the origin determinant of each excitation in the dets array
    """

    cdef size_t det_idx
    cdef unsigned long num_dets = occ_orbs.shape[0]
    cdef unsigned int num_elec = occ_orbs.shape[1]
    cdef unsigned int num_orb = orb_symm.shape[0]
    cdef unsigned int n_unocc = num_orb - num_elec / 2
    cdef unsigned int n_same = num_elec * (num_elec / 2 - 1) / 2 * n_unocc * (n_unocc - 1) / 2
    cdef unsigned int n_diff = num_elec / 2 * num_elec / 2 * n_unocc ** 2
    cdef unsigned int tot_sampl = num_dets * (n_same + n_diff)
    
    cdef numpy.ndarray[numpy.uint8_t, ndim=2] chosen_orbs = numpy.zeros([tot_sampl, 4], 
                                                                          dtype=numpy.uint8)
    for det_idx in range(num_dets):
        _doub_ex(dets[det_idx], occ_orbs[det_idx], &chosen_orbs[det_idx * (n_same + 
                                                                n_diff), 0], num_orb)

    idx_arr = numpy.arange(num_dets, dtype=numpy.uint32)
    idx_arr.shape = (-1, 1)
    idx_arr = numpy.tile(idx_arr, (1, n_same + n_diff))
    idx_arr.shape = (-1)

    successes = (orb_symm[chosen_orbs[:, 0] % num_orb] ^ 
                 orb_symm[chosen_orbs[:, 1] % num_orb] ^ 
                 orb_symm[chosen_orbs[:, 2] % num_orb] ^ 
                 orb_symm[chosen_orbs[:, 3] % num_orb]) == 0
    return chosen_orbs[successes], idx_arr[successes]

cdef void _doub_ex(long long det, unsigned char[:] occ_orbs, unsigned char *res_arr,
                    unsigned int num_orb):
    """
    Generate all spin-allowed double excitations from a Slater determinant.
    """
    cdef unsigned int num_elec = occ_orbs.shape[0]
    cdef unsigned char i, i_orb, j, j_orb, k, l
    cdef unsigned int idx = 0
    # Different-spin excitations
    for i in range(num_elec / 2):
        i_orb = occ_orbs[i]
        for j in range(num_elec / 2, num_elec):
            j_orb = occ_orbs[j]
            for k in range(num_orb):
                if not(det & (<long long> 1 << k)):
                    for l in range(num_orb, 2 * num_orb):
                        if not(det & (<long long> 1 << l)):
                            res_arr[idx] = i_orb
                            res_arr[idx + 1] = j_orb
                            res_arr[idx + 2] = k
                            res_arr[idx + 3] = l
                            idx += 4
    # Same-spin (up) excitations
    for i in range(num_elec / 2):
        i_orb = occ_orbs[i]
        for j in range(i + 1, num_elec / 2):
            j_orb = occ_orbs[j]
            for k in range(num_orb):
                if not(det & (<long long> 1 << k)):
                    for l in range(k + 1, num_orb):
                        if not(det & (<long long> 1 << l)):
                            res_arr[idx] = i_orb
                            res_arr[idx + 1] = j_orb
                            res_arr[idx + 2] = k
                            res_arr[idx + 3] = l
                            idx += 4
    # Same-spin (down) excitations
    for i in range(num_elec / 2, num_elec):
        i_orb = occ_orbs[i]
        for j in range(i + 1, num_elec):
            j_orb = occ_orbs[j]
            for k in range(num_orb, 2 * num_orb):
                if not(det & (<long long> 1 << k)):
                    for l in range(k + 1, 2 * num_orb):
                        if not(det & (<long long> 1 << l)):
                            res_arr[idx] = i_orb
                            res_arr[idx + 1] = j_orb
                            res_arr[idx + 2] = k
                            res_arr[idx + 3] = l
                            idx += 4


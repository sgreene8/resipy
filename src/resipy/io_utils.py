#!/usr/bin/env python2
"""
Subroutines for file I/O operations
"""
import numpy


def setup_results(buf_len, res_dir, calc_ray, fciqmc, shift_int=0):
    """Initialize the file handles for writing results and their corresponding
        buffer arrays.

        Parameters
        ----------
        buf_len : (unsigned int)
            The number of iterations between writing results to disk.
        res_dir : (str)
            The directory in which results should be saved
        calc_ray : (bool)
            A flag that specifies whether to save the Rayleigh quotient
        fciqmc : (bool)
            A flag that specifies whether this is a fciqmc calculation, and
            therefore whether to save the energy shift, number of walkers, and
            solution vector sparsity.
        shift_int : (unsigned int)
            For fciqmc calculations, the number of iterations between updates
            to the energy shift.
    """
    r_dict = {}
    if fciqmc:
        r_dict['shift'] = [open(res_dir + 'S.txt', 'ab', 0),
                           numpy.zeros(buf_len / shift_int)]
        r_dict['n_walk'] = [open(res_dir + 'N.txt', 'ab', 0),
                            numpy.zeros(buf_len / shift_int, dtype=numpy.int32)]
        r_dict['sparsity'] = [open(res_dir + 'sparsity.txt', 'ab', 0),
                              numpy.zeros(buf_len / shift_int, dtype=numpy.int32)]
        r_dict['shift_int'] = shift_int
    if calc_ray:
        r_dict['ray_num'] = [open(res_dir + 'raynum.txt', 'ab', 0),
                             numpy.zeros(buf_len / shift_int)]
        r_dict['ray_den'] = [open(res_dir + 'rayden.txt', 'ab', 0),
                             numpy.zeros(buf_len / shift_int)]
    r_dict['proj_num'] = [open(res_dir + 'projnum.txt', 'ab', 0),
                          numpy.zeros(buf_len)]
    r_dict['proj_den'] = [open(res_dir + 'projden.txt', 'ab', 0),
                          numpy.zeros(buf_len)]
    r_dict['buf_len'] = buf_len
    r_dict['vec_file'] = res_dir + 'vec'
    return r_dict


def calc_results(r_dict, vec, shift, iter_num, hf_col):
    """Estimate the correlation energy from the current iterate and write results
        to file, if necessary.

        Parameters
        ----------
        r_dict : (dict)
            dictionary containing results arrays, file handles, and other info,
            generated by the setup_results subroutine
        vec : (SparseVector)
            Current iterate
        shift : (float)
            for FCIQMC calculations, the current value of the energy shift
        iter_num : (unsigned int)
            index of the current iteration in the trajectory
        hf_col : (SparseVector)
            HF column of the FCI matrix, including the HF determinant
            itself
    """
    buf_len = r_dict['buf_len']
    res_idx = iter_num % buf_len
    if vec.indices[0] != hf_col.indices[0]:
        r_dict['proj_den'][1][res_idx] = 0
    else:
        r_dict['proj_den'][1][res_idx] = vec.values[0]
    r_dict['proj_num'][1][res_idx] = vec.dot(hf_col)
    print(iter_num, r_dict['proj_num'][1]
          [res_idx] / r_dict['proj_den'][1][res_idx])

    if 'shift' in r_dict:
        shift_int = r_dict['shift_int']
        r_dict['shift'][1][res_idx / shift_int] = shift
    if 'n_walk' in r_dict:
        r_dict['n_walk'][1][res_idx /
                            shift_int] = vec.one_norm()
    if 'sparsity' in r_dict:
        r_dict['sparsity'][1][res_idx / shift_int] = vec.indices.shape[0]

    if ((iter_num + 1) % buf_len) == 0:
        numpy.savetxt(r_dict['proj_num'][0], r_dict['proj_num'][1])
        numpy.savetxt(r_dict['proj_den'][0], r_dict['proj_den'][1])
        vec.save(r_dict['vec_file'])
        if 'shift' in r_dict:
            numpy.savetxt(r_dict['shift'][0], r_dict['shift'][1])
        if 'n_walk' in r_dict:
            numpy.savetxt(r_dict['n_walk'][0], r_dict['n_walk'][1])
        if 'sparsity' in r_dict:
            numpy.savetxt(r_dict['sparsity'][0], r_dict['sparsity'][1])


def read_in_hf(hf_path, n_frozen):
    """Read in and process the output files from a pyscf HF calculation

        Parameters
        ----------
        hf_path : (str)
            Directory containing output files from the HF calculation
        n_frozen : (unsigned int)
            Desired number of electrons to be frozen in the calculation

        Returns
        -------
        (numpy.ndarray) :
            2-D array containing the 1-electron integrals in the spatial orbital basis
        (numpy.ndarray) :
            4-D array containing the 2-electron integrals in the spatial orbital basis
        (numpy.ndarray) :
            1-D array containing the irreducible representations of each spatial orbital
        (float) :
            Hartree-Fock electronic energy
    """
    h_core = numpy.load(hf_path + 'hcore.npy')

    eris = numpy.load(hf_path + 'eris.npy')

    symm = numpy.load(hf_path + 'symm.npy')
    symm = symm[(n_frozen / 2):]

    hf_en = numpy.genfromtxt(hf_path + 'hf_en.txt')

    return h_core, eris, symm, hf_en
